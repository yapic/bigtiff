import time
import unittest
import os
import numpy as np

from bigtiff import Tiff, PlaceHolder

FILENAME = os.path.join(os.path.dirname(__file__),'foo.tif')

class TestTiff(unittest.TestCase):
    def test_memmap(self):
        with Tiff.from_file(FILENAME) as tif:
            for img in tif:
                arr = img.memmap()
                arr[:10, :10, 0] = 99


    def test_load(self):
        with Tiff.from_file(FILENAME) as tif:
            for img in tif:
                t = img.tags


    def test_write_place_holder(self):
        images = [PlaceHolder((20, 10, 1), 'float32'), PlaceHolder((20, 10, 1), 'float32')]
        out = '/tmp/bar.tif'
        Tiff.write(images, io=out)

        with Tiff.from_file(out) as tif:
            for img in tif:
                arr = img.memmap()
                arr[0,0,0] = 99
                arr[0,1,0] = 200


    def test_write_place_holder_fast(self):
        '''Should only run on a Linux system with ext4 or XFS filesystem'''
        images = [PlaceHolder((20000, 10000, 1), 'uint8')]
        out = '/tmp/bar2.tif'

        start = time.time()

        Tiff.write(images, io=out)

        with Tiff.from_file(out) as tif:
            for img in tif:
                arr = img.memmap()
                arr[0,0,0] = 99
                arr[9999,9999,0] = 200

        end = time.time()
        assert end - start < 1 # sec


    def test_write(self):
        with Tiff.from_file(FILENAME) as tif:
            io = Tiff.write([np.atleast_3d([1]).astype('uint8'), np.atleast_3d([255]).astype('uint8')], closefd=False)
            actual = io.getvalue()
        with open('/tmp/foo1.tif', 'bw') as f:
            f.write(actual)

        expected = b'II+\x00\x08\x00\x00\x00' # header
        expected += b'\x10\x00\x00\x00\x00\x00\x00\x00' # first ifd position
        expected += b'\x0b\x00\x00\x00\x00\x00\x00\x00' # 13 entries
        expected += b'\x00\x01\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x01\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x03\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x06\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x16\x01\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x17\x01\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x1a\x01\x05\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x1b\x01\x05\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00S\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x11\x01\x10\x00\x01\x00\x00\x00\x00\x00\x00\x00\xfc\x00\x00\x00\x00\x00\x00\x00\xfd\x00\x00\x00\x00\x00\x00\x00\x01\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x01\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x01\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x02\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x03\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x06\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x16\x01\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x17\x01\x04\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x1a\x01\x05\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00\x1b\x01\x05\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x01\x00\x00\x00S\x01\x03\x00\x01\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x11\x01\x10\x00\x01\x00\x00\x00\x00\x00\x00\x00\xe9\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xff'

        np.testing.assert_array_equal(actual, expected)


if __name__ == '__main__':
    unittest.main()
